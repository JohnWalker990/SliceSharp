// <auto-generated/>
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.FindSymbols;

namespace SliceSharp.Cli;


/// <summary>
/// Builds a static call/type dependency graph from a root method
/// (with DI awareness, AutoMapper & EF Core heuristics, and SymbolFinder fallbacks).
/// </summary>
internal sealed class DependencyGraphBuilder
{
    #region PRIVATE-FIELDS
    private readonly Solution _solution;
    private readonly FileIgnoreRules _ignorer;
    private readonly int _maxDepth;
    private readonly DiRegistry _di;
    private readonly Dictionary<DocumentId, SemanticModel> _modelCache = new();
    #endregion

    #region CTOR
    public DependencyGraphBuilder(Solution solution, FileIgnoreRules ignorer, int maxDepth, DiRegistry diRegistry)
    {
        _solution = solution;
        _ignorer = ignorer;
        _maxDepth = Math.Max(1, maxDepth);
        _di = diRegistry;
    }
    #endregion

    #region PUBLIC-METHODS
    public async Task<DependencyGraph> BuildAsync(IMethodSymbol rootMethod, Document rootDoc)
    {
        var graph = new DependencyGraph();
        var q = new Queue<(ISymbol sym, Document doc, int depth)>();
        var visited = new HashSet<ISymbol>(SymbolEqualityComparer.Default);

        q.Enqueue((rootMethod, rootDoc, 0));
        graph.Add(rootMethod, rootDoc);

        // Also enqueue the containing type for ctor/property scan (helps DI ctor params).
        if (rootMethod.ContainingType?.DeclaringSyntaxReferences.Length > 0 == true)
        {
            var ct = rootMethod.ContainingType;
            var ctDoc = _solution.GetDocument(ct.DeclaringSyntaxReferences[0].SyntaxTree);
            if (ctDoc != null)
            {
                q.Enqueue((ct, ctDoc, 0));
                graph.Add(ct, ctDoc);
            }
        }

        while (q.Count > 0)
        {
            var (current, doc, depth) = q.Dequeue();
            if (!visited.Add(current))
                continue;
            if (depth >= _maxDepth)
                continue;

            var deps = await GetDependenciesAsync(current, doc);
            foreach (var dep in deps)
            {
                if (dep.Symbol is null || dep.Document is null)
                    continue;
                if (_ignorer.IsIgnored(dep.Document.FilePath))
                    continue;

                graph.Add(dep.Symbol, dep.Document);
                graph.AddEdge(current, dep.Symbol);
                q.Enqueue((dep.Symbol, dep.Document, depth + 1));
            }
        }

        return graph;
    }
    #endregion

    #region PRIVATE-METHODS
    private async Task<(SemanticModel model, SyntaxNode root)> GetModelAsync(Document doc)
    {
        if (!_modelCache.TryGetValue(doc.Id, out var model))
        {
            model = await doc.GetSemanticModelAsync().ConfigureAwait(false)
                    ?? throw new InvalidOperationException("Failed to get SemanticModel for " + doc.Name);
            _modelCache[doc.Id] = model;
        }
        var root = await doc.GetSyntaxRootAsync().ConfigureAwait(false)
                   ?? throw new InvalidOperationException("Failed to get SyntaxRoot for " + doc.Name);
        return (model, root);
    }

    private async Task<List<SymbolAndDocument>> GetDependenciesAsync(ISymbol symbol, Document doc)
    {
        var result = new List<SymbolAndDocument>();
        var (model, root) = await GetModelAsync(doc);

        if (symbol is IMethodSymbol ms)
        {
            // (A) Parameter & return types
            foreach (var t in GetRelevantTypes(ms))
            {
                var td = await FindDeclarationDocumentAsync(t);
                if (td != null)
                    result.Add(new SymbolAndDocument(t, td));
            }

            var decl = ms.DeclaringSyntaxReferences.FirstOrDefault()?.GetSyntax();
            if (decl is MethodDeclarationSyntax mds)
            {
                // (B) Attribute typeof(T) (e.g., ProducesResponseType(typeof(Dto)))
                foreach (var attrList in mds.AttributeLists)
                {
                    foreach (var attr in attrList.Attributes)
                    {
                        foreach (var arg in attr.ArgumentList?.Arguments ?? default!)
                        {
                            if (arg.Expression is TypeOfExpressionSyntax to)
                            {
                                var t = model.GetSymbolInfo(to.Type).Symbol as INamedTypeSymbol;
                                if (t != null && t.DeclaringSyntaxReferences.Length > 0)
                                {
                                    var ddoc = await FindDeclarationDocumentAsync(t);
                                    if (ddoc != null)
                                        result.Add(new SymbolAndDocument(t, ddoc));
                                }
                            }
                        }
                    }
                }

                // (C) Invocations (calls) incl. DI interface->impl and AutoMapper
                var invocations = mds.DescendantNodes().OfType<InvocationExpressionSyntax>();
                foreach (var inv in invocations)
                {
                    var info = model.GetSymbolInfo(inv);
                    var called = info.Symbol as IMethodSymbol ?? info.CandidateSymbols.OfType<IMethodSymbol>().FirstOrDefault();
                    if (called != null && called.DeclaringSyntaxReferences.Length > 0)
                    {
                        var (declDoc, _) = await GetDocumentAndRootAsync(called);
                        if (declDoc != null)
                            result.Add(new SymbolAndDocument(called, declDoc));
                    }

                    // DI: interface method -> implementations
                    if (called != null && called.ContainingType?.TypeKind == TypeKind.Interface)
                    {
                        var iface = (INamedTypeSymbol)called.ContainingType;

                        // DI mapping
                        foreach (var impl in _di.GetImplementations(iface))
                        {
                            var match = impl.GetMembers().OfType<IMethodSymbol>()
                                .FirstOrDefault(m => m.Name == called.Name && m.Parameters.Length == called.Parameters.Length);
                            if (match != null && match.DeclaringSyntaxReferences.Length > 0)
                            {
                                var (implDoc, _) = await GetDocumentAndRootAsync(match);
                                if (implDoc != null)
                                    result.Add(new SymbolAndDocument(match, implDoc));
                            }
                            else
                            {
                                var (implTypeDoc, _) = await GetDocumentAndRootAsync(impl);
                                if (implTypeDoc != null)
                                    result.Add(new SymbolAndDocument(impl, implTypeDoc));
                            }
                        }

                        // SymbolFinder fallback
                        var implMethods = await SymbolFinder.FindImplementationsAsync(called, _solution, cancellationToken: System.Threading.CancellationToken.None);
                        foreach (var im in implMethods.OfType<IMethodSymbol>())
                        {
                            if (im.DeclaringSyntaxReferences.Length == 0)
                                continue;
                            var (implDoc, _) = await GetDocumentAndRootAsync(im);
                            if (implDoc != null)
                                result.Add(new SymbolAndDocument(im, implDoc));
                        }
                    }

                    // AutoMapper heuristics: Map<Dest>(...), ProjectTo<Dest>(...)
                    if (called != null && IsAutoMapperMethod(called))
                    {
                        // 1) Semantic generic args
                        foreach (var ta in called.TypeArguments.OfType<INamedTypeSymbol>())
                        {
                            var ddoc = await FindDeclarationDocumentAsync(ta);
                            if (ddoc != null)
                                result.Add(new SymbolAndDocument(ta, ddoc));
                        }
                        // 2) Syntactic generic args (in case of reduced generic info)
                        if (inv.Expression is GenericNameSyntax gname)
                        {
                            foreach (var a in gname.TypeArgumentList.Arguments)
                            {
                                var t = model.GetSymbolInfo(a).Symbol as INamedTypeSymbol;
                                if (t != null)
                                {
                                    var ddoc = await FindDeclarationDocumentAsync(t);
                                    if (ddoc != null)
                                        result.Add(new SymbolAndDocument(t, ddoc));
                                }
                            }
                        }
                        else if (inv.Expression is MemberAccessExpressionSyntax maes && maes.Name is GenericNameSyntax mg)
                        {
                            foreach (var a in mg.TypeArgumentList.Arguments)
                            {
                                var t = model.GetSymbolInfo(a).Symbol as INamedTypeSymbol;
                                if (t != null)
                                {
                                    var ddoc = await FindDeclarationDocumentAsync(t);
                                    if (ddoc != null)
                                        result.Add(new SymbolAndDocument(t, ddoc));
                                }
                            }
                        }

                        // 3) Pull in AutoMapper Profile classes from the same project (keeps scope tight)
                        await AddAutoMapperProfilesFromProjectAsync(doc, result);
                    }
                }

                // (D) Object creations -> add constructed types
                var news = mds.DescendantNodes().OfType<ObjectCreationExpressionSyntax>();
                foreach (var n in news)
                {
                    var tinfo = model.GetTypeInfo(n);
                    var t = tinfo.Type ?? tinfo.ConvertedType;
                    if (t != null && t.DeclaringSyntaxReferences.Length > 0)
                    {
                        var (declDoc, _) = await GetDocumentAndRootAsync(t);
                        if (declDoc != null)
                            result.Add(new SymbolAndDocument(t, declDoc));
                    }
                }

                // (E) EF Core: expressions whose type is DbSet<T> -> include T
                var exprs = mds.DescendantNodes().OfType<ExpressionSyntax>();
                foreach (var expr in exprs)
                {
                    var t = model.GetTypeInfo(expr).Type as INamedTypeSymbol;
                    if (t != null && IsDbSet(t))
                    {
                        var entity = t.TypeArguments.FirstOrDefault() as INamedTypeSymbol;
                        if (entity != null && entity.DeclaringSyntaxReferences.Length > 0)
                        {
                            var edoc = await FindDeclarationDocumentAsync(entity);
                            if (edoc != null)
                                result.Add(new SymbolAndDocument(entity, edoc));
                        }
                    }
                }
            }
        }
        else if (symbol is INamedTypeSymbol ts)
        {
            // constructors (and DI for interface-typed ctor params)
            foreach (var ctor in ts.Constructors.Where(c => c.DeclaringSyntaxReferences.Length > 0))
            {
                var (declDoc, _) = await GetDocumentAndRootAsync(ctor);
                if (declDoc != null)
                    result.Add(new SymbolAndDocument(ctor, declDoc));

                foreach (var p in ctor.Parameters)
                {
                    if (p.Type is INamedTypeSymbol pif && pif.TypeKind == TypeKind.Interface)
                    {
                        foreach (var impl in _di.GetImplementations(pif))
                        {
                            var (implDoc, _) = await GetDocumentAndRootAsync(impl);
                            if (implDoc != null)
                                result.Add(new SymbolAndDocument(impl, implDoc));
                        }

                        var implTypes = await SymbolFinder.FindImplementationsAsync(pif, _solution, cancellationToken: System.Threading.CancellationToken.None);
                        foreach (var it in implTypes.OfType<INamedTypeSymbol>())
                        {
                            if (it.DeclaringSyntaxReferences.Length == 0)
                                continue;
                            var (implDoc, _) = await GetDocumentAndRootAsync(it);
                            if (implDoc != null)
                                result.Add(new SymbolAndDocument(it, implDoc));
                        }
                    }
                }
            }

            // properties -> their types
            foreach (var prop in ts.GetMembers().OfType<IPropertySymbol>())
            {
                var pt = prop.Type as INamedTypeSymbol;
                if (pt != null && pt.DeclaringSyntaxReferences.Length > 0)
                {
                    var (declDoc, _) = await GetDocumentAndRootAsync(pt);
                    if (declDoc != null)
                        result.Add(new SymbolAndDocument(pt, declDoc));
                }
            }

            // EF Core: if type is DbContext -> include DbSet<TEntity> and IEntityTypeConfiguration<TEntity> in project
            if (IsDbContext(ts))
            {
                var entityTypes = new List<INamedTypeSymbol>();
                foreach (var prop in ts.GetMembers().OfType<IPropertySymbol>())
                {
                    if (prop.Type is INamedTypeSymbol ptn && IsDbSet(ptn))
                    {
                        var entity = ptn.TypeArguments.FirstOrDefault() as INamedTypeSymbol;
                        if (entity != null)
                        {
                            var edoc = await FindDeclarationDocumentAsync(entity);
                            if (edoc != null)
                                result.Add(new SymbolAndDocument(entity, edoc));
                            entityTypes.Add(entity);
                        }
                    }
                }

                // IEntityTypeConfiguration<TEntity> in same project
                if (entityTypes.Count > 0)
                {
                    var project = _solution.GetProject(doc.Project.Id);
                    if (project != null)
                    {
                        foreach (var d in project.Documents)
                        {
                            if (_ignorer.IsIgnored(d.FilePath))
                                continue;
                            var r = await d.GetSyntaxRootAsync().ConfigureAwait(false);
                            var m = await d.GetSemanticModelAsync().ConfigureAwait(false);
                            if (r is null || m is null)
                                continue;

                            foreach (var cls in r.DescendantNodes().OfType<ClassDeclarationSyntax>())
                            {
                                var csym = m.GetDeclaredSymbol(cls) as INamedTypeSymbol;
                                if (csym == null || csym.DeclaringSyntaxReferences.Length == 0)
                                    continue;

                                if (ImplementsIEntityTypeConfigurationOfAny(csym, entityTypes))
                                {
                                    result.Add(new SymbolAndDocument(csym, d));
                                }
                            }
                        }
                    }
                }
            }
        }

        return result;
    }

    // ---------- Helpers ----------

    private static IEnumerable<INamedTypeSymbol> GetRelevantTypes(IMethodSymbol ms)
    {
        var set = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);
        void AddType(ITypeSymbol? t)
        {
            if (t is INamedTypeSymbol nts && nts.DeclaringSyntaxReferences.Length > 0)
                set.Add(nts);
        }
        AddType(ms.ReturnType);
        foreach (var p in ms.Parameters)
            AddType(p.Type);
        return set;
    }

    private async Task<(Document? doc, SyntaxNode? root)> GetDocumentAndRootAsync(ISymbol s)
    {
        var decl = s.DeclaringSyntaxReferences.FirstOrDefault();
        if (decl == null)
            return (null, null);
        var tree = decl.SyntaxTree;
        var doc = _solution.GetDocument(tree);
        if (doc == null)
            return (null, null);
        var root = await doc.GetSyntaxRootAsync().ConfigureAwait(false);
        return (doc, root);
    }

    private async Task<Document?> FindDeclarationDocumentAsync(INamedTypeSymbol t)
    {
        var decl = t.DeclaringSyntaxReferences.FirstOrDefault();
        if (decl == null)
            return null;
        var tree = decl.SyntaxTree;
        return _solution.GetDocument(tree);
    }

    private static bool IsAutoMapperMethod(IMethodSymbol called)
    {
        var ns = called.ContainingNamespace?.ToDisplayString() ?? "";
        var ct = called.ContainingType?.ToDisplayString() ?? "";
        if (ns.StartsWith("AutoMapper", StringComparison.Ordinal) || ct.StartsWith("AutoMapper", StringComparison.Ordinal))
            return true;

        // Common names (fallback)
        return called.Name is "Map" or "ProjectTo";
    }

    private async Task AddAutoMapperProfilesFromProjectAsync(Document doc, List<SymbolAndDocument> bucket)
    {
        var project = _solution.GetProject(doc.Project.Id);
        if (project == null)
            return;

        foreach (var d in project.Documents)
        {
            if (_ignorer.IsIgnored(d.FilePath))
                continue;
            var r = await d.GetSyntaxRootAsync().ConfigureAwait(false);
            var m = await d.GetSemanticModelAsync().ConfigureAwait(false);
            if (r is null || m is null)
                continue;

            foreach (var cls in r.DescendantNodes().OfType<ClassDeclarationSyntax>())
            {
                var csym = m.GetDeclaredSymbol(cls) as INamedTypeSymbol;
                if (csym == null)
                    continue;
                if (DerivesFrom(csym, "AutoMapper.Profile"))
                {
                    bucket.Add(new SymbolAndDocument(csym, d));
                }
            }
        }
    }

    private static bool DerivesFrom(INamedTypeSymbol type, string fullBaseTypeName)
    {
        var bt = type.BaseType;
        while (bt != null)
        {
            var s = bt.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            if (s.Contains(fullBaseTypeName, StringComparison.Ordinal))
                return true;
            bt = bt.BaseType;
        }
        return false;
    }

    private static bool IsDbContext(INamedTypeSymbol type)
    {
        var bt = type;
        while (bt != null)
        {
            var s = bt.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            if (s.Contains("Microsoft.EntityFrameworkCore.DbContext", StringComparison.Ordinal))
                return true;
            bt = bt.BaseType;
        }
        return false;
    }

    private static bool IsDbSet(INamedTypeSymbol t)
    {
        var od = t.OriginalDefinition;
        return od.Name == "DbSet" && od.Arity == 1 &&
               od.ContainingNamespace?.ToDisplayString() == "Microsoft.EntityFrameworkCore";
    }

    private static bool ImplementsIEntityTypeConfigurationOfAny(INamedTypeSymbol type, IEnumerable<INamedTypeSymbol> entities)
    {
        foreach (var iface in type.AllInterfaces)
        {
            if (iface.Name == "IEntityTypeConfiguration" &&
                iface.Arity == 1 &&
                iface.ContainingNamespace?.ToDisplayString() == "Microsoft.EntityFrameworkCore")
            {
                var arg = iface.TypeArguments[0];
                if (entities.Any(e => SymbolEqualityComparer.Default.Equals(e, arg)))
                    return true;
            }
        }
        return false;
    }

    private readonly record struct SymbolAndDocument(ISymbol? Symbol, Document? Document);

    #endregion

}