// <auto-generated/>
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace SliceSharp.Cli;

/// <summary>
/// Scans Program.cs/Startup.cs (and other files) for DI registrations and builds a registry.
/// Supports: AddTransient/AddScoped/AddSingleton with generic type args or typeof(...) args.
/// Partial support for Scrutor Scan(...).AddClasses().AsImplementedInterfaces().
/// </summary>
internal sealed class DiRegistryScanner
{
    private readonly FileIgnoreRules _ignorer;

    public DiRegistryScanner(FileIgnoreRules ignorer) => _ignorer = ignorer;

    public async Task<DiRegistry> BuildRegistryAsync(Solution solution)
    {
        var registry = new DiRegistry();

        var allDocs = solution.Projects.SelectMany(p => p.Documents).ToList();
        foreach (var doc in allDocs)
        {
            var path = doc.FilePath ?? "";
            if (_ignorer.IsIgnored(path))
                continue;

            var root = await doc.GetSyntaxRootAsync().ConfigureAwait(false);
            var model = await doc.GetSemanticModelAsync().ConfigureAwait(false);
            if (root is null || model is null)
                continue;

            var invocations = root.DescendantNodes().OfType<InvocationExpressionSyntax>();

            foreach (var inv in invocations)
            {
                var sym = model.GetSymbolInfo(inv).Symbol as IMethodSymbol;
                if (sym == null)
                    continue;
                var name = sym.Name;

                if (name is "AddTransient" or "AddScoped" or "AddSingleton")
                {
                    // Generic form: services.AddScoped<IService, Impl>()
                    var gname = GetGenericName(inv);
                    if (gname != null && gname.TypeArgumentList.Arguments.Count >= 1)
                    {
                        if (gname.TypeArgumentList.Arguments.Count == 2)
                        {
                            var serviceType = model.GetSymbolInfo(gname.TypeArgumentList.Arguments[0]).Symbol as INamedTypeSymbol;
                            var implType = model.GetSymbolInfo(gname.TypeArgumentList.Arguments[1]).Symbol as INamedTypeSymbol;
                            if (serviceType != null && serviceType.TypeKind == TypeKind.Interface && implType != null)
                            {
                                registry.Add(serviceType, implType);
                                continue;
                            }
                        }
                    }

                    // typeof form: services.AddScoped(typeof(IService), typeof(Impl))
                    var args = inv.ArgumentList?.Arguments;
                    if (args != null && args.Value.Count >= 2)
                    {
                        var a0 = args.Value[0].Expression as TypeOfExpressionSyntax;
                        var a1 = args.Value[1].Expression as TypeOfExpressionSyntax;
                        if (a0 != null && a1 != null)
                        {
                            var serviceType = model.GetSymbolInfo(a0.Type).Symbol as INamedTypeSymbol;
                            var implType = model.GetSymbolInfo(a1.Type).Symbol as INamedTypeSymbol;
                            if (serviceType != null && serviceType.TypeKind == TypeKind.Interface && implType != null)
                            {
                                registry.Add(serviceType, implType);
                                continue;
                            }
                        }
                    }

                    // Descriptor form: services.Add(new ServiceDescriptor(typeof(IService), typeof(Impl), ...))
                    if (name == "Add" && args != null && args.Value.Count >= 1)
                    {
                        if (args.Value[0].Expression is ObjectCreationExpressionSyntax oce)
                        {
                            var type = model.GetSymbolInfo(oce.Type).Symbol as INamedTypeSymbol;
                            if (type != null && type.Name == "ServiceDescriptor")
                            {
                                var typeofs = oce.ArgumentList?.Arguments.Select(a => a.Expression).OfType<TypeOfExpressionSyntax>().ToList() ?? new();
                                if (typeofs.Count >= 2)
                                {
                                    var serviceType = model.GetSymbolInfo(typeofs[0].Type).Symbol as INamedTypeSymbol;
                                    var implType = model.GetSymbolInfo(typeofs[1].Type).Symbol as INamedTypeSymbol;
                                    if (serviceType != null && serviceType.TypeKind == TypeKind.Interface && implType != null)
                                    {
                                        registry.Add(serviceType, implType);
                                        continue;
                                    }
                                }
                            }
                        }
                    }
                }
                else if (name == "Scan")
                {
                    // Scrutor-like
                    var descendantText = inv.ToString();
                    if (descendantText.Contains("AsImplementedInterfaces", StringComparison.Ordinal))
                    {
                        var gens = inv.DescendantNodes().OfType<GenericNameSyntax>()
                            .Where(gn => gn.Identifier.Text == "FromAssemblyOf" && gn.TypeArgumentList.Arguments.Count == 1)
                            .ToList();
                        var limitAssemblies = new HashSet<IAssemblySymbol>(SymbolEqualityComparer.Default);

                        foreach (var gn in gens)
                        {
                            var tSym = model.GetSymbolInfo(gn.TypeArgumentList.Arguments[0]).Symbol as INamedTypeSymbol;
                            if (tSym?.ContainingAssembly != null)
                                limitAssemblies.Add(tSym.ContainingAssembly);
                        }
                        if (limitAssemblies.Count == 0 && model.Compilation.Assembly != null)
                            limitAssemblies.Add(model.Compilation.Assembly);

                        var projects = solution.Projects.Where(p => p.AssemblyName != null && limitAssemblies.Any(a => a.Name == p.AssemblyName));
                        foreach (var proj in projects)
                        {
                            foreach (var d in proj.Documents)
                            {
                                var p = d.FilePath ?? "";
                                if (_ignorer.IsIgnored(p))
                                    continue;
                                var r = await d.GetSyntaxRootAsync().ConfigureAwait(false);
                                var m = await d.GetSemanticModelAsync().ConfigureAwait(false);
                                if (r is null || m is null)
                                    continue;

                                var classes = r.DescendantNodes().OfType<ClassDeclarationSyntax>();
                                foreach (var cls in classes)
                                {
                                    var type = m.GetDeclaredSymbol(cls) as INamedTypeSymbol;
                                    if (type == null || type.IsAbstract || type.TypeKind != TypeKind.Class)
                                        continue;
                                    foreach (var iface in type.AllInterfaces)
                                        registry.Add(iface, type);
                                }
                            }
                        }
                    }
                }
            }
        }

        return registry;
    }

    private static GenericNameSyntax? GetGenericName(InvocationExpressionSyntax inv)
    {
        if (inv.Expression is GenericNameSyntax g)
            return g;
        if (inv.Expression is MemberAccessExpressionSyntax ma && ma.Name is GenericNameSyntax gn)
            return gn;
        return null;
    }
}