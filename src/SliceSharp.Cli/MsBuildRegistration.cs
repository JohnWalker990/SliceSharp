// <auto-generated/>
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

using Microsoft.Build.Locator;

namespace SliceSharp.Cli;



/// <summary>
/// Robust MSBuild registration logic with multiple fallbacks.
/// </summary>
internal static class MsBuildRegistration
{
    #region PUBLIC-METHODS

    /// <summary>
    /// Ensures MSBuild is registered for MSBuildWorkspace.
    /// Priority:
    /// 1) CLI override path (--msbuildPath)
    /// 2) Env vars
    /// 3) .NET SDK (prefer same major as current runtime)
    /// 4) MSBuildLocator.RegisterDefaults()
    /// 5) Known VS paths
    /// 6) QueryVisualStudioInstances()
    /// </summary>
    public static void EnsureRegistered(string? cliPathOverride = null)
    {
        if (MSBuildLocator.IsRegistered)
            return;

        // 1) CLI override
        if (RegisterIfValid(cliPathOverride))
            return;

        // 2) Environment variables
        var envCandidates = new string?[]
        {
                Environment.GetEnvironmentVariable("SLICESHARP_MSBUILD_PATH"),
                Environment.GetEnvironmentVariable("MSBUILD_EXE_PATH"),
                TryCombine(Environment.GetEnvironmentVariable("VSINSTALLDIR"), "MSBuild", "Current", "Bin")
        };
        foreach (var p in envCandidates)
            if (RegisterIfValid(p))
                return;

        // 3) .NET SDK (prefer same major as runtime)
        if (TryRegisterFromDotnetSdk())
            return;

        // 4) Defaults (may succeed)
        try
        { MSBuildLocator.RegisterDefaults(); return; }
        catch { /* continue */ }

        // 5) Common VS paths
        foreach (var p in ProbeCommonMsbuildPaths())
            if (RegisterIfValid(p))
                return;

        // 6) VS instances
        try
        {
            var instances = MSBuildLocator.QueryVisualStudioInstances()
                                          .OrderByDescending(i => i.Version)
                                          .ToArray();
            if (instances.Length > 0)
            {
                MSBuildLocator.RegisterInstance(instances[0]);
                return;
            }
        }
        catch { /* ignore */ }

        throw new InvalidOperationException(
            "No instances of MSBuild could be detected. Installiere das passende .NET SDK (z. B. 8.x für Runtime 8) " +
            "oder VS Build Tools, oder übergib --msbuildPath auf einen Ordner mit MSBuild.dll.");
    }


    #endregion

    #region PRIVATE-METHODS

    /// <summary>
    /// Registers MSBuild from the .NET SDK (prefers SDKs whose major equals current runtime major).
    /// </summary>
    private static bool TryRegisterFromDotnetSdk()
    {
        foreach (var dir in ProbeDotnetSdkMsbuildPaths(preferRuntimeMajor: true))
            if (RegisterIfValid(dir))
                return true;

        // Fallback: any SDK (if preferRuntimeMajor yielded none)
        foreach (var dir in ProbeDotnetSdkMsbuildPaths(preferRuntimeMajor: false))
            if (RegisterIfValid(dir))
                return true;

        return false;
    }

    /// <summary>
    /// Enumerates SDK folders that contain MSBuild.dll. When preferRuntimeMajor=true,
    /// yields SDKs whose version.Major equals the current runtime major first (newest to oldest).
    /// Otherwise yields all SDKs (newest to oldest).
    /// </summary>
    private static IEnumerable<string> ProbeDotnetSdkMsbuildPaths(bool preferRuntimeMajor)
    {
        var roots = new List<string?>();
        var dotnetRoot = Environment.GetEnvironmentVariable("DOTNET_ROOT");
        if (!string.IsNullOrWhiteSpace(dotnetRoot))
            roots.Add(dotnetRoot);
        roots.Add(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles), "dotnet"));
        roots.Add(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ProgramFilesX86), "dotnet"));
        roots.Add("/usr/share/dotnet");
        roots.Add("/usr/local/share/dotnet");

        int runtimeMajor = Environment.Version.Major;

        foreach (var root in roots.Where(r => !string.IsNullOrWhiteSpace(r) && Directory.Exists(r!)).Cast<string>())
        {
            var sdkDir = Path.Combine(root, "sdk");
            if (!Directory.Exists(sdkDir))
                continue;

            var all = Directory.GetDirectories(sdkDir)
                .Select(d => (dir: d, ver: TryParseVersion(Path.GetFileName(d))))
                .Where(t => t.ver is not null)
                .OrderByDescending(t => t.ver)
                .ToList();

            IEnumerable<(string dir, Version? ver)> seq = all;
            if (preferRuntimeMajor)
            {
                var preferred = all.Where(t => t.ver!.Major == runtimeMajor).ToList();
                if (preferred.Count == 0)
                    continue; // try next root, then fall back in outer call
                seq = preferred;
            }

            foreach (var t in seq)
            {
                var msbuildDll = Path.Combine(t.dir, "MSBuild.dll");
                if (File.Exists(msbuildDll))
                    yield return t.dir;
            }
        }
    }

    /// <summary>
    /// Try to parse a version like "9.0.304".
    /// </summary>
    private static Version? TryParseVersion(string? s)
        => Version.TryParse(s, out var v) ? v : null;

    private static bool RegisterIfValid(string? pathOrExe)
    {
        if (string.IsNullOrWhiteSpace(pathOrExe))
            return false;

        string dir = pathOrExe;
        if (File.Exists(pathOrExe) && pathOrExe.EndsWith(".exe", StringComparison.OrdinalIgnoreCase))
            dir = Path.GetDirectoryName(pathOrExe)!;

        if (!Directory.Exists(dir))
            return false;

        var dllPath = Path.Combine(dir, "MSBuild.dll");
        if (!File.Exists(dllPath))
        {
            var parent = Directory.GetParent(dir)?.FullName;
            if (parent is null || !File.Exists(Path.Combine(parent, "MSBuild.dll")))
                return false;
            dir = parent;
        }

        try
        { MSBuildLocator.RegisterMSBuildPath(dir); return true; }
        catch { return false; }
    }

    private static IEnumerable<string> ProbeCommonMsbuildPaths()
    {
        var result = new List<string>();
        var pf64 = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles);
        var pf86 = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFilesX86);
        var editions = new[] { "Enterprise", "Professional", "Community", "BuildTools", "Preview" };

        foreach (var ed in editions)
        {
            result.Add(Path.Combine(pf64, "Microsoft Visual Studio", "2022", ed, "MSBuild", "Current", "Bin"));
            result.Add(Path.Combine(pf64, "Microsoft Visual Studio", "2022", ed, "MSBuild", "17.0", "Bin"));
        }
        foreach (var ed in editions)
        {
            result.Add(Path.Combine(pf86, "Microsoft Visual Studio", "2019", ed, "MSBuild", "Current", "Bin"));
            result.Add(Path.Combine(pf86, "Microsoft Visual Studio", "2019", ed, "MSBuild", "16.0", "Bin"));
        }
        result.Add(Path.Combine(pf86, "MSBuild", "14.0", "Bin"));
        return result;
    }

    private static string? TryCombine(string? a, params string[] rest)
    {
        if (string.IsNullOrWhiteSpace(a))
            return null;
        var parts = new List<string> { a! };
        parts.AddRange(rest);
        return Path.Combine(parts.ToArray());
    }


    #endregion
}