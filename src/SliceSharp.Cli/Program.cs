// <auto-generated/>
using System;
using System.IO;
using System.Threading.Tasks;

using Microsoft.Build.Locator;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.MSBuild;

namespace SliceSharp.Cli;

/// <summary>
/// Entry point for the SliceSharp CLI.
/// Loads a solution, resolves a root (file#method or route:METHOD:/path),
/// builds a static dependency slice (incl. DI resolution), and exports Slice.md and graph.dot.
/// </summary>
public static class Program
{
    #region PUBLIC-METHODS
    /// <summary>
    /// Application entry point.
    /// </summary>
    public static async Task<int> Main(string[] args)
    {
        try
        {
            var options = CliOptions.Parse(args);
            if (!options.IsValid(out var validationError))
            {
                Console.Error.WriteLine(validationError);
                CliOptions.PrintUsage();
                return 2;
            }

            // Register MSBuild (required by MSBuildWorkspace)
            // Use robust multi-strategy registration (CLI override, env vars, known paths, VS instances)
            MsBuildRegistration.EnsureRegistered(options.MSBuildPath);

            var ignorer = new FileIgnoreRules(options.ExcludePatterns);
            using var workspace = MSBuildWorkspace.Create();
            workspace.WorkspaceFailed += (s, e) =>
            {
                // Non-fatal diagnostics can happen; keep going but log them.
                Console.Error.WriteLine("[MSBuildWorkspace] " + e.Diagnostic.Message);
            };

            var solution = await workspace.OpenSolutionAsync(options.SolutionPath);
            var rootResolver = new RootResolver(solution, ignorer);
            var (rootMethod, rootDoc) = await rootResolver.ResolveAsync(options.RootSpec);
            if (rootMethod is null || rootDoc is null)
                throw new InvalidOperationException("Root method not found. Check --root spec.");

            // Build DI registry for interface->implementation mapping.
            var diScanner = new DiRegistryScanner(ignorer);
            var diRegistry = await diScanner.BuildRegistryAsync(solution);

            var builder = new DependencyGraphBuilder(solution, ignorer, options.MaxDepth, diRegistry);
            var graph = await builder.BuildAsync(rootMethod, rootDoc);

            var exporter = new SliceExporter(options, ignorer);
            await exporter.ExportAsync(graph, rootMethod);

            Console.WriteLine("Slice generated successfully.");
            Console.WriteLine("Output: " + Path.GetFullPath(options.OutputDir));
            return 0;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine("ERROR: " + ex.Message);
            Console.Error.WriteLine(ex);
            return 1;
        }
    }
    #endregion
}
