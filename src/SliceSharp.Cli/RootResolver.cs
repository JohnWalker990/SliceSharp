// <auto-generated/>
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace SliceSharp.Cli
{
    /// <summary>
    /// Resolves the root method symbol based on a file#method or route:METHOD:/path spec.
    /// </summary>
    internal sealed class RootResolver
    {
        #region PRIVATE-FIELDS
        private readonly Solution _solution;
        private readonly FileIgnoreRules _ignorer;
        #endregion

        #region CTOR
        /// <summary>
        /// Initializes a new instance of the RootResolver class.
        /// </summary>
        public RootResolver(Solution solution, FileIgnoreRules ignorer)
        {
            _solution = solution;
            _ignorer = ignorer;
        }
        #endregion

        #region PUBLIC-METHODS
        /// <summary>
        /// Resolves a root method from a spec string.
        /// </summary>
        public async Task<(IMethodSymbol? method, Document? document)> ResolveAsync(string rootSpec)
        {
            if (rootSpec.StartsWith("route:", StringComparison.OrdinalIgnoreCase))
            {
                return await ResolveByRouteAsync(rootSpec);
            }
            else
            {
                return await ResolveByFileAndMethodAsync(rootSpec);
            }
        }
        #endregion

        #region PRIVATE-METHODS
        /// <summary>
        /// Resolves a root method from a "file.cs#MethodName" spec.
        /// Signature hints in parentheses are optional: "MethodName(int)".
        /// </summary>
        private async Task<(IMethodSymbol? method, Document? document)> ResolveByFileAndMethodAsync(string rootSpec)
        {
            var parts = rootSpec.Split('#', 2);
            if (parts.Length != 2) return (null, null);

            var filePart = NormalizePath(parts[0]);
            var methodPart = parts[1];

            var allDocs = _solution.Projects.SelectMany(p => p.Documents).ToList();

            var doc = allDocs.FirstOrDefault(d =>
            {
                var path = d.FilePath ?? "";
                if (string.IsNullOrEmpty(path) || _ignorer.IsIgnored(path)) return false;
                var dp = NormalizePath(path);
                return dp.EndsWith(filePart, StringComparison.OrdinalIgnoreCase) ||
                       dp.Equals(filePart, StringComparison.OrdinalIgnoreCase);
            });

            if (doc is null) return (null, null);

            var root = await doc.GetSyntaxRootAsync().ConfigureAwait(false);
            var model = await doc.GetSemanticModelAsync().ConfigureAwait(false);
            if (root is null || model is null) return (null, null);

            string methodName = methodPart.Contains('(')
                ? methodPart[..methodPart.IndexOf('(')]
                : methodPart;

            var candidates = root.DescendantNodes()
                .OfType<MethodDeclarationSyntax>()
                .Where(m => string.Equals(m.Identifier.Text, methodName, StringComparison.Ordinal))
                .ToList();

            if (candidates.Count == 0) return (null, null);

            // If signature is provided, try to match parameter count (simple heuristic)
            if (methodPart.Contains('(') && methodPart.EndsWith(")"))
            {
                var inside = methodPart[(methodPart.IndexOf('(') + 1)..(methodPart.Length - 1)];
                var paramHints = inside.Split(',', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);
                candidates = candidates
                    .OrderByDescending(m => m.ParameterList.Parameters.Count == paramHints.Length ? 1 : 0)
                    .ThenBy(m => m.ParameterList.Parameters.Count)
                    .ToList();
            }

            var chosen = candidates.First();
            var symbol = (await doc.GetSemanticModelAsync().ConfigureAwait(false))?.GetDeclaredSymbol(chosen) as IMethodSymbol;
            return (symbol, doc);
        }

        /// <summary>
        /// Resolves a root method from a route spec: route:METHOD:/absolute/path
        /// Supports Controller attributes: [Route] on class, [HttpGet]/[HttpPost]/[Route] on method, [AcceptVerbs].
        /// </summary>
        private async Task<(IMethodSymbol? method, Document? document)> ResolveByRouteAsync(string routeSpec)
        {
            // route:GET:/api/orders/42
            var m = Regex.Match(routeSpec, @"^route:(?<verb>[A-Za-z]+):(?<path>/.*)$", RegexOptions.IgnoreCase);
            if (!m.Success) return (null, null);
            var verb = m.Groups["verb"].Value.ToUpperInvariant();
            var path = m.Groups["path"].Value;

            var candidates = new List<(IMethodSymbol method, Document doc, int score)>();

            foreach (var project in _solution.Projects)
            {
                foreach (var doc in project.Documents)
                {
                    var filePath = doc.FilePath ?? "";
                    if (_ignorer.IsIgnored(filePath)) continue;

                    var root = await doc.GetSyntaxRootAsync().ConfigureAwait(false);
                    var model = await doc.GetSemanticModelAsync().ConfigureAwait(false);
                    if (root is null || model is null) continue;

                    var classes = root.DescendantNodes().OfType<ClassDeclarationSyntax>();
                    foreach (var cls in classes)
                    {
                        var type = model.GetDeclaredSymbol(cls) as INamedTypeSymbol;
                        if (type is null) continue;
                        if (!IsController(type)) continue;

                        var classRoutes = GetRouteTemplates(type);
                        var controllerName = type.Name.EndsWith("Controller", StringComparison.OrdinalIgnoreCase) ? type.Name[..^"Controller".Length] : type.Name;

                        foreach (var member in type.GetMembers().OfType<IMethodSymbol>())
                        {
                            if (member.DeclaredAccessibility != Accessibility.Public) continue;
                            if (member.MethodKind != MethodKind.Ordinary) continue;

                            var actionRoutes = GetActionRoutes(member);
                            if (actionRoutes.Count == 0) continue; // ignore non-action methods

                            foreach (var ar in actionRoutes)
                            {
                                // Compose full templates combining class route(s) and action template(s)
                                var classTemplates = classRoutes.Count > 0 ? classRoutes : new List<RouteTemplate> { new RouteTemplate { Template = "", HttpMethods = new HashSet<string>() } };
                                foreach (var cr in classTemplates)
                                {
                                    var full = ComposeTemplate(cr.Template, ar.Template, controllerName, member.Name);
                                    // Match HTTP verb
                                    var allowedVerbs = ar.HttpMethods.Count > 0 ? ar.HttpMethods : (cr.HttpMethods.Count > 0 ? cr.HttpMethods : new HashSet<string> { "GET", "POST", "PUT", "DELETE", "PATCH" });
                                    if (allowedVerbs.Count > 0 && !allowedVerbs.Contains(verb)) continue;

                                    // Match path
                                    var score = RouteUtils.MatchScore(full, path);
                                    if (score >= 0)
                                    {
                                        candidates.Add((member, doc, score));
                                    }
                                }
                            }
                        }
                    }
                }
            }

            if (candidates.Count == 0) return (null, null);

            // Highest score wins (more concrete segments matched)
            var best = candidates.OrderByDescending(c => c.score).First();
            return (best.method, best.doc);
        }

        private static bool IsController(INamedTypeSymbol type)
        {
            // Heuristics: ends with Controller OR derives from ControllerBase OR has [ApiController] attribute
            if (type.Name.EndsWith("Controller", StringComparison.OrdinalIgnoreCase)) return true;
            if (DerivesFrom(type, "Microsoft.AspNetCore.Mvc.ControllerBase")) return true;
            if (HasAttribute(type, "Microsoft.AspNetCore.Mvc.ApiControllerAttribute")) return true;
            return false;
        }

        private static bool DerivesFrom(INamedTypeSymbol type, string fullBaseTypeName)
        {
            var bt = type.BaseType;
            while (bt != null)
            {
                if (bt.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat).Contains(fullBaseTypeName, StringComparison.Ordinal)) return true;
                bt = bt.BaseType;
            }
            return false;
        }

        private static bool HasAttribute(ISymbol symbol, string fullAttributeName)
        {
            return symbol.GetAttributes().Any(a => a.AttributeClass?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat).Contains(fullAttributeName, StringComparison.Ordinal) == true);
        }

        private static List<RouteTemplate> GetRouteTemplates(INamedTypeSymbol type)
        {
            var list = new List<RouteTemplate>();
            foreach (var a in type.GetAttributes())
            {
                var name = a.AttributeClass?.Name;
                if (name is null) continue;
                if (name.Equals("RouteAttribute", StringComparison.Ordinal) || name.Equals("Route", StringComparison.Ordinal))
                {
                    var template = a.ConstructorArguments.Length > 0 ? a.ConstructorArguments[0].Value as string ?? "" : "";
                    var methods = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                    list.Add(new RouteTemplate { Template = template, HttpMethods = methods });
                }
            }
            return list;
        }

        private static List<RouteTemplate> GetActionRoutes(IMethodSymbol method)
        {
            var list = new List<RouteTemplate>();
            var anyHttpAttr = false;

            foreach (var a in method.GetAttributes())
            {
                var an = a.AttributeClass?.Name ?? "";
                var fn = a.AttributeClass?.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat) ?? "";

                bool isRoute = an.Equals("RouteAttribute", StringComparison.Ordinal) || an.Equals("Route", StringComparison.Ordinal);
                bool isHttp = an.StartsWith("Http", StringComparison.Ordinal) && an.EndsWith("Attribute", StringComparison.Ordinal);
                bool isAcceptVerbs = an.Equals("AcceptVerbsAttribute", StringComparison.Ordinal) || an.Equals("AcceptVerbs", StringComparison.Ordinal);

                if (isRoute)
                {
                    var template = a.ConstructorArguments.Length > 0 ? a.ConstructorArguments[0].Value as string ?? "" : "";
                    list.Add(new RouteTemplate { Template = template, HttpMethods = new HashSet<string>(StringComparer.OrdinalIgnoreCase) });
                }
                else if (isHttp)
                {
                    anyHttpAttr = true;
                    var verb = an.Replace("Attribute", "", StringComparison.Ordinal);
                    // e.g., HttpGet -> GET
                    verb = verb.Length > 4 ? verb.Substring(4).ToUpperInvariant() : verb.ToUpperInvariant();
                    var template = a.ConstructorArguments.Length > 0 ? a.ConstructorArguments[0].Value as string ?? "" : "";
                    list.Add(new RouteTemplate { Template = template, HttpMethods = new HashSet<string>(StringComparer.OrdinalIgnoreCase) { verb } });
                }
                else if (isAcceptVerbs)
                {
                    anyHttpAttr = true;
                    var methods = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                    if (a.ConstructorArguments.Length > 0)
                    {
                        var arg0 = a.ConstructorArguments[0];
                        if (arg0.Kind == TypedConstantKind.Array && arg0.Values.Length > 0)
                        {
                            foreach (var v in arg0.Values)
                            {
                                var s = v.Value as string;
                                if (!string.IsNullOrWhiteSpace(s)) methods.Add(s.ToUpperInvariant());
                            }
                        }
                        else if (arg0.Value is string s1)
                        {
                            methods.Add(s1.ToUpperInvariant());
                        }
                    }
                    var template = (a.ConstructorArguments.Length > 1) ? (a.ConstructorArguments[1].Value as string ?? "") : "";
                    list.Add(new RouteTemplate { Template = template, HttpMethods = methods });
                }
            }

            // If no attribute routes at all, we consider this not an action for our route-based resolver.
            return list;
        }

        private static string ComposeTemplate(string classTemplate, string actionTemplate, string controllerName, string actionName)
        {
            string Join(string a, string b)
            {
                if (string.IsNullOrEmpty(a)) return b ?? "";
                if (string.IsNullOrEmpty(b)) return a ?? "";
                if (a.EndsWith("/")) return a + b.TrimStart('/');
                else return a.TrimEnd('/') + "/" + b.TrimStart('/');
            }

            var t = Join(classTemplate ?? "", actionTemplate ?? "");
            t = t.Replace("[controller]", controllerName, StringComparison.OrdinalIgnoreCase)
                 .Replace("[action]", actionName, StringComparison.OrdinalIgnoreCase);
            if (!t.StartsWith("/")) t = "/" + t;
            return t;
        }

        private static string NormalizePath(string path)
        {
            path = path.Replace('/', Path.DirectorySeparatorChar).Replace('\\', Path.DirectorySeparatorChar);
            return Path.GetFullPath(path, Environment.CurrentDirectory);
        }
        #endregion

        #region PRIVATE-TYPES
        /// <summary>
        /// Simple container for a route template with allowed HTTP methods.
        /// </summary>
        private sealed class RouteTemplate
        {
            /// <summary>
            /// Route template (e.g., "api/orders/{id}" or "").
            /// </summary>
            public string Template { get; set; } = "";

            /// <summary>
            /// Allowed HTTP methods (uppercase). Empty means "any".
            /// </summary>
            public HashSet<string> HttpMethods { get; set; } = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        }
        #endregion
    }
}
