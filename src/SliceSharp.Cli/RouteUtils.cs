// <auto-generated/>
using System;
using System.Linq;

namespace SliceSharp.Cli
{
    /// <summary>
    /// Route matching helpers.
    /// </summary>
    internal static class RouteUtils
    {
        #region PUBLIC-METHODS
        /// <summary>
        /// Returns a non-negative score if the given concrete path matches the route template.
        /// Higher scores mean more specific match (more literal segments matched).
        /// Returns -1 on no match.
        /// </summary>
        public static int MatchScore(string template, string concretePath)
        {
            template = Normalize(template);
            concretePath = Normalize(concretePath);

            var tSegs = template.Split('/', StringSplitOptions.RemoveEmptyEntries);
            var pSegs = concretePath.Split('/', StringSplitOptions.RemoveEmptyEntries);

            int i = 0, j = 0;
            int score = 0;
            while (i < tSegs.Length && j < pSegs.Length)
            {
                var ts = tSegs[i];
                var ps = pSegs[j];

                if (IsCatchAll(ts))
                {
                    // Match the rest
                    score += 0; // catch-all doesn't add specificity
                    return score;
                }

                if (IsParameter(ts))
                {
                    // Parameter matches anything in this segment
                    i++; j++; continue;
                }

                if (ts.Equals(ps, StringComparison.OrdinalIgnoreCase))
                {
                    score += 2; // literal segment match adds specificity
                    i++; j++; continue;
                }

                // No match
                return -1;
            }

            // If template has remaining non-optional segments, fail.
            if (i < tSegs.Length)
            {
                // Remaining segments must all be optional parameters or catch-all
                for (; i < tSegs.Length; i++)
                {
                    if (!IsCatchAll(tSegs[i]) && !IsOptionalParameter(tSegs[i])) return -1;
                }
            }

            // If path has remaining segments but template ended (without catch-all), fail.
            if (j < pSegs.Length) return -1;

            return score;
        }
        #endregion

        #region PRIVATE-METHODS
        private static string Normalize(string p)
        {
            if (string.IsNullOrWhiteSpace(p)) return "/";
            if (!p.StartsWith("/")) p = "/" + p;
            // Remove query string if any
            var q = p.IndexOf('?');
            if (q >= 0) p = p.Substring(0, q);
            return p;
        }

        private static bool IsParameter(string seg)
        {
            if (seg.StartsWith("{") && seg.EndsWith("}"))
            {
                // e.g., {id}, {id?}, {id:int}, {**slug}
                if (seg.StartsWith("{*") || seg.StartsWith("{**"))
                    return false; // treated as catch-all
                return true;
            }
            return false;
        }

        private static bool IsOptionalParameter(string seg)
        {
            if (seg.StartsWith("{") && seg.EndsWith("}"))
            {
                return seg.Contains('?');
            }
            return false;
        }

        private static bool IsCatchAll(string seg)
        {
            return seg.StartsWith("{*") || seg.StartsWith("{**");
        }
        #endregion
    }
}
