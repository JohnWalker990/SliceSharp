// <auto-generated/>
using System;
using System.IO;
using System.Text;
using System.Threading.Tasks;

using Microsoft.CodeAnalysis;

namespace SliceSharp.Cli;



/// <summary>
/// Exports the slice into Slice.md (full code until budget) and graph.dot (GraphViz).
/// </summary>
internal sealed class SliceExporter
{
    #region PRIVATE-FIELDS
    private readonly CliOptions _options;
    private readonly FileIgnoreRules _ignorer;
    #endregion

    #region CTOR
    public SliceExporter(CliOptions options, FileIgnoreRules ignorer)
    {
        _options = options;
        _ignorer = ignorer;
    }
    #endregion

    #region PUBLIC-METHODS
    public async Task ExportAsync(DependencyGraph graph, IMethodSymbol root)
    {
        Directory.CreateDirectory(_options.OutputDir);
        var sliceMdPath = Path.Combine(_options.OutputDir, "Slice.md");
        var graphDotPath = Path.Combine(_options.OutputDir, "graph.dot");

        var charBudget = (int)Math.Floor(_options.TokenBudget * _options.AvgCharsPerToken);
        var sb = new StringBuilder(4096);

        // Header
        sb.AppendLine("# Slice Pack");
        sb.AppendLine();
        sb.AppendLine($"- Root: `{root.ToDisplayString()}`");
        sb.AppendLine($"- Budget: ~{_options.TokenBudget} tokens (~{charBudget} chars @ {_options.AvgCharsPerToken:0.##}/token)");
        sb.AppendLine($"- Max Depth: {_options.MaxDepth}");
        sb.AppendLine($"- Files (ordered by proximity): {graph.Documents.Count}");
        sb.AppendLine();
        sb.AppendLine("> Rules: Generated files, Migrations and Tests excluded. Contains only code relevant to the root by static analysis. DI/Route resolution enabled; AutoMapper/EF heuristics and minification active in this build.");
        sb.AppendLine();

        int used = sb.Length;

        // Index
        sb.AppendLine("## Index");
        foreach (var d in graph.Documents)
        {
            if (_ignorer.IsIgnored(d.FilePath))
                continue;
            var rel = MakeRelative(d.FilePath ?? string.Empty);
            sb.AppendLine($"- {rel}");
        }

        sb.AppendLine();
        used = sb.Length;

        // Files (minified) with full code until budget
        sb.AppendLine("## Files");
        foreach (var d in graph.Documents)
        {
            if (_ignorer.IsIgnored(d.FilePath))
                continue;

            var rel = MakeRelative(d.FilePath ?? string.Empty);
            sb.AppendLine();
            sb.AppendLine($"### {rel}");
            sb.AppendLine();
            sb.AppendLine("```csharp");

            // *** Minify here ***
            var content = await CodeMinifier.MinifyDocumentAsync(
                d,
                stripBoilerplate: _options.StripBoilerplate,
                stripBlankLines: _options.StripBoilerplate // same switch for simplicity
            ).ConfigureAwait(false);

            if (_options.EmbedFullCode)
            {
                if (used + content.Length + 16 > charBudget)
                {
                    var remaining = Math.Max(0, charBudget - used - 16);
                    if (remaining > 0)
                    {
                        if (remaining < content.Length)
                            content = content.Substring(0, remaining) + "\n// --- TRUNCATED DUE TO BUDGET ---";
                    }
                    else
                    {
                        content = "// Skipped due to budget.";
                    }
                }
            }
            else
            {
                content = "// Full code embedding disabled in options.";
            }

            sb.AppendLine(content);
            sb.AppendLine("```");

            used = sb.Length;
            if (used >= charBudget)
                break;
        }

        await File.WriteAllTextAsync(sliceMdPath, sb.ToString(), new UTF8Encoding(false));

        // GraphViz export
        var dot = BuildDot(graph);
        await File.WriteAllTextAsync(graphDotPath, dot, new UTF8Encoding(false));
    }
    #endregion

    #region PRIVATE-METHODS
    private static string MakeRelative(string path)
    {
        try
        {
            var cwd = Environment.CurrentDirectory;
            var rel = Path.GetRelativePath(cwd, path);
            return rel;
        }
        catch
        {
            return path;
        }
    }

    private static string Display(ISymbol s)
    {
        return s.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
    }

    private static string BuildDot(DependencyGraph graph)
    {
        var sb = new StringBuilder();
        sb.AppendLine("digraph Slice {");
        sb.AppendLine("  rankdir=LR;");

        var ids = new System.Collections.Generic.Dictionary<ISymbol, string>(SymbolEqualityComparer.Default);
        int i = 0;
        foreach (var s in graph.Symbols)
        {
            var id = "n" + i++;
            ids[s] = id;
            var label = Display(s).Replace("\"", "'");
            sb.AppendLine($"  {id} [label=\"{label}\"];");
        }

        foreach (var (from, to) in graph.Edges)
        {
            if (!ids.TryGetValue(from, out var f) || !ids.TryGetValue(to, out var t))
                continue;
            sb.AppendLine($"  {f} -> {t};");
        }

        sb.AppendLine("}");
        return sb.ToString();
    }
    #endregion
}
